-- Create the table for user profiles
create table profiles (
  id uuid references auth.users not null primary key,
  updated_at timestamp with time zone,
  xp int not null default 0
);

-- Function to create a profile for a new user
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id)
  values (new.id);
  return new;
end;
$$ language plpgsql security definer;

-- Trigger to call the function when a new user signs up
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Helper function to check for admin role
create or replace function public.is_admin()
returns boolean as $$
begin
  return (select auth.jwt() -> 'user_metadata' ->> 'role') = 'admin';
end;
$$ language plpgsql security definer;

-- Enable Row Level Security for profiles
alter table public.profiles enable row level security;
create policy "Public profiles are viewable by everyone." on profiles for select using (true);
create policy "Users can insert their own profile." on profiles for insert with check (auth.uid() = id);
create policy "Users can update their own profile." on profiles for update using (auth.uid() = id);

-- Create table for content submissions
create table submissions (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone not null default now(),
  topic text,
  writer text,
  status text,
  content jsonb,
  exam_level text,
  image_data_uri text
);

-- Enable Row Level Security for submissions
alter table public.submissions enable row level security;
create policy "Admins can view all submissions." on submissions for select using (public.is_admin());
create policy "Admins can insert submissions." on submissions for insert with check (public.is_admin());
create policy "Admins can update submissions." on submissions for update using (public.is_admin());
create policy "Approved submissions are viewable by authenticated users." on submissions for select to authenticated using (status = 'Approved'::text);

-- Create table for stories
create table stories (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone not null default now(),
  title text,
  story text,
  image_data_uri text
);
-- Enable Row Level Security for stories
alter table public.stories enable row level security;
create policy "Stories are public." on stories for select using (true);
create policy "Admins can create stories." on stories for insert with check (public.is_admin());

-- Create table for posts
create table posts (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone not null default now(),
  content text,
  author_name text,
  author_avatar text
);
-- Enable Row Level Security for posts
alter table public.posts enable row level security;
create policy "Posts are public." on posts for select using (true);
create policy "Authenticated users can create posts." on posts for insert with check (auth.role() = 'authenticated');

-- Create table for payments
create table payments (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone not null default now(),
  user_name text,
  payment_type text,
  amount numeric,
  status text,
  receipt_url text
);
-- Enable Row Level Security for payments
alter table public.payments enable row level security;
create policy "Payments are viewable by admins." on payments for select using (public.is_admin());
create policy "Authenticated users can create payments." on payments for insert with check (auth.role() = 'authenticated');
create policy "Admins can update payments." on payments for update using (public.is_admin());

-- Create table for quest completions
create table quest_completions (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  submission_id bigint references submissions not null,
  score int not null,
  total_questions int not null,
  created_at timestamp with time zone not null default now(),
  unique (user_id, submission_id)
);
-- Enable Row Level Security for quest_completions
alter table public.quest_completions enable row level security;
create policy "Users can view their own completions." on quest_completions for select using (auth.uid() = user_id);
create policy "Users can insert their own completions." on quest_completions for insert with check (auth.uid() = user_id);

-- RPC to award XP
create or replace function award_xp(user_id_in uuid, xp_to_add int)
returns void as $$
begin
  update public.profiles
  set xp = xp + xp_to_add
  where id = user_id_in;
end;
$$ language plpgsql security definer;

-- RPC to get leaderboard
create or replace function get_leaderboard()
returns table(rank bigint, id uuid, name text, xp int, avatar_url text, avatar_hint text) as $$
begin
  return query
  select
    row_number() over (order by p.xp desc) as rank,
    p.id,
    u.raw_user_meta_data ->> 'name' as name,
    p.xp,
    u.raw_user_meta_data ->> 'avatar_url' as avatar_url,
    u.raw_user_meta_data ->> 'avatar_hint' as avatar_hint
  from
    public.profiles p
  join
    auth.users u on p.id = u.id
  order by
    p.xp desc
  limit 100;
end;
$$ language plpgsql stable;

-- Set up Storage for receipts
-- This part must be done via the Supabase UI as per the README instructions.
-- The policies below are included for completeness but must be applied to the bucket in the Supabase Dashboard.

-- Bucket: 'receipts', Public: true

-- create policy "Knights can upload their own receipts."
-- on storage.objects for insert with check (
--   bucket_id = 'receipts'
--   and auth.uid()::text = (storage.foldername(name))[1]
-- );

-- create policy "Anyone can view public receipts"
-- on storage.objects for select using (
--   bucket_id = 'receipts'
-- );
